"""
SFZ Generator - Utility to create SFZ instrument definitions from WAV files

This tool generates SFZ instrument definitions by scanning directories for WAV files
and mapping them to MIDI keys starting from a configurable base note.

Part of the RCY (Recycling) audio tool suite.
"""

import argparse
import os
import logging
from typing import List, Optional, Dict, Any

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(levelname)s: %(message)s')
logger = logging.getLogger(__name__)


def is_audio_file(filename: str, extensions: List[str] = None) -> bool:
    """
    Check if a file is a valid audio file based on its extension.
    
    Args:
        filename: The filename to check
        extensions: List of valid extensions (without the dot). Defaults to ['.wav']
    
    Returns:
        bool: True if the file is a valid audio file, False otherwise
    """
    if extensions is None:
        extensions = ['.wav']
    
    # Add the dot if not present in the extensions
    extensions = [ext if ext.startswith('.') else f'.{ext}' for ext in extensions]
    
    # Check if file is a hidden file or system file
    if filename.startswith('.') or filename.startswith('._'):
        return False
    
    # Check if file has valid extension
    return any(filename.lower().endswith(ext) for ext in extensions)


def collect_audio_files(root_dir: str, extensions: List[str] = None) -> List[str]:
    """
    Recursively collect audio files from a directory.
    
    Args:
        root_dir: The root directory to scan
        extensions: List of valid extensions (without the dot). Defaults to ['.wav']
    
    Returns:
        List[str]: List of relative paths to audio files
    """
    if extensions is None:
        extensions = ['wav']
    
    audio_files = []
    for dirpath, _, filenames in os.walk(root_dir):
        for f in sorted(filenames):
            if is_audio_file(f, extensions):
                rel_path = os.path.relpath(os.path.join(dirpath, f), start=root_dir)
                # Convert Windows backslashes to forward slashes for SFZ compatibility
                rel_path = rel_path.replace('\\', '/')
                audio_files.append(rel_path)
    
    return audio_files


def generate_sfz(audio_files: List[str], start_key: int = 36, 
                group_id: Optional[int] = None, 
                additional_params: Optional[Dict[str, Any]] = None,
                input_dir: Optional[str] = None) -> str:
    """
    Generate SFZ content from a list of audio files.
    
    Args:
        audio_files: List of audio file paths
        start_key: Starting MIDI key (default: 36 = C1)
        group_id: Optional group ID for SFZ regions
        additional_params: Additional parameters to add to each region
        input_dir: Input directory path for setting up the default_path control
    
    Returns:
        str: SFZ content as a string
    """
    lines = []
    
    # Add a header comment
    lines.append("// SFZ instrument definition")
    lines.append(f"// Generated by RCY SFZ Generator")
    lines.append(f"// {len(audio_files)} samples mapped from key {start_key}")
    lines.append("")
    
    # Add default_path control for better compatibility
    if input_dir:
        # Use the input directory as provided, without exposing full system paths
        # This works with most samplers as long as the SFZ is in the right location
        if not input_dir.endswith('/'):
            input_dir += '/'
        
        lines.append("<control>")
        lines.append(f"default_path={input_dir}")
        lines.append("</control>")
        lines.append("")
    
    for i, audio_path in enumerate(audio_files):
        key = start_key + i
        
        # Extract just the filename part for use with default_path
        if input_dir:
            sample_path = os.path.basename(audio_path)
        else:
            sample_path = audio_path
        
        # Build the region line
        region = [f"<region> sample={sample_path} key={key}"]
        
        # Add optional group ID if provided
        if group_id is not None:
            region.append(f"group={group_id}")
        
        # Add any additional parameters
        if additional_params:
            for param, value in additional_params.items():
                region.append(f"{param}={value}")
        
        lines.append(" ".join(region))
    
    return "\n".join(lines)


def main():
    """Main entry point for the SFZ generator tool."""
    parser = argparse.ArgumentParser(description="Generate SFZ from directory of audio files")
    parser.add_argument("-i", "--input", 
                        help="Input root directory to scan for audio files")
    parser.add_argument("-o", "--output", default="output.sfz", 
                        help="Output SFZ file name (default: output.sfz)")
    parser.add_argument("--start-key", type=int, default=36, 
                        help="Starting MIDI key (default: 36 = C1)")
    parser.add_argument("--group-id", type=int, 
                        help="Optional group ID for SFZ regions")
    parser.add_argument("--extensions", nargs="+", default=["wav"], 
                        help="Audio file extensions to include (default: wav)")
    parser.add_argument("--verbose", "-v", action="store_true", 
                        help="Enable verbose output")

    args = parser.parse_args()
    
    # If no input directory is provided, show help and exit
    if not args.input:
        parser.print_help()
        print("\nExamples:")
        print("  Generate SFZ from a directory of WAV files:")
        print("    generate_sfz.py -i /path/to/samples -o output.sfz")
        print("\n  Use custom starting key (middle C):")
        print("    generate_sfz.py -i /path/to/samples -o output.sfz --start-key 60")
        print("\n  Include multiple audio formats:")
        print("    generate_sfz.py -i /path/to/samples -o output.sfz --extensions wav aif mp3")
        return 0

    # Configure logging level
    if args.verbose:
        logger.setLevel(logging.DEBUG)

    input_dir = args.input
    output_path = args.output
    start_key = args.start_key
    group_id = args.group_id
    extensions = args.extensions

    # Validate input directory
    if not os.path.exists(input_dir):
        logger.error(f"Input path '{input_dir}' does not exist.")
        return 1
    
    if not os.path.isdir(input_dir):
        logger.error(f"Input path '{input_dir}' is not a directory.")
        return 1

    # Collect audio files
    logger.info(f"Scanning {input_dir} for audio files with extensions: {extensions}")
    audio_files = collect_audio_files(input_dir, extensions)
    
    if not audio_files:
        logger.warning(f"No audio files found in {input_dir}.")
        return 0

    logger.info(f"Found {len(audio_files)} audio files")
    
    # Generate SFZ content using the default_path approach
    sfz_content = generate_sfz(
        audio_files, 
        start_key=start_key, 
        group_id=group_id,
        input_dir=input_dir
    )
    
    # Create output directory if it doesn't exist
    output_dir = os.path.dirname(output_path)
    if output_dir and not os.path.exists(output_dir):
        os.makedirs(output_dir)
    
    # Write SFZ file
    with open(output_path, "w") as f:
        f.write(sfz_content)

    logger.info(f"Successfully generated SFZ with {len(audio_files)} samples")
    logger.info(f"SFZ file written to: {os.path.abspath(output_path)}")
    
    return 0


if __name__ == "__main__":
    exit(main())