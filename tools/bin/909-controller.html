<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>S2800 Controller</title>
<script src="https://cdn.jsdelivr.net/npm/webmidi@3/dist/iife/webmidi.iife.js"></script>
<style>
* { box-sizing: border-box; margin: 0; padding: 0; }
body {
  background: #1a1a1a;
  color: #e8e0c8;
  font-family: 'Courier New', monospace;
  min-height: 100vh;
  padding: 16px;
  user-select: none;
  -webkit-user-select: none;
}
header { margin-bottom: 10px; display: flex; align-items: baseline; gap: 16px; flex-wrap: wrap; }

#sticky-header {
  position: sticky;
  top: 0;
  background: #1a1a1a;
  z-index: 100;
  padding-bottom: 12px;
  border-bottom: 2px solid #333;
}

#scrollable-body {
  padding-top: 8px;
}
h1 { font-size: 11px; letter-spacing: 4px; color: #f0a020; text-transform: uppercase; white-space: nowrap; }
#prog-select {
  background: #2a2a2a;
  color: #e8e0c8;
  border: 1px solid #444;
  border-radius: 3px;
  font-family: inherit;
  font-size: 9px;
  letter-spacing: 1px;
  padding: 3px 6px;
  cursor: pointer;
  min-width: 180px;
}
#prog-select:focus { outline: 1px solid #f0a020; }
#midi-bar    { font-size: 9px; color: #555; letter-spacing: 1px; width: 100%; }
#status      { font-size: 9px; color: #666; letter-spacing: 1px; height: 14px; width: 100%; }
#status.ok   { color: #4a4; }
#status.err  { color: #a44; }
#status.info { color: #88a; }

.section-label {
  font-size: 8px;
  letter-spacing: 3px;
  text-transform: uppercase;
  color: #555;
  margin: 12px 0 6px;
}

/* Program-level knob row */
#prog-panel {
  display: flex;
  gap: 12px;
  flex-wrap: wrap;
  background: #1e1e1e;
  border: 1px solid #333;
  border-radius: 4px;
  padding: 10px 14px;
  align-items: center;
}
.prog-knob-group {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 2px;
}
.prog-knob-label { font-size: 7px; letter-spacing: 1px; color: #777; text-transform: uppercase; }
.prog-knob-name  { font-size: 7px; letter-spacing: 1px; color: #555; text-transform: uppercase; }
.prog-knob-value { font-size: 8px; color: #bbb; min-width: 30px; text-align: center; }

/* Per-keygroup panel */
#panel {
  display: flex;
  gap: 8px;
  overflow-x: auto;
  background: #242424;
  border: 1px solid #333;
  border-radius: 4px;
  padding: 12px;
  min-height: 60px;
}
#panel-loading {
  font-size: 9px;
  color: #555;
  letter-spacing: 2px;
  padding: 8px;
  align-self: center;
}
.voice {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 5px;
  min-width: 70px;
  padding: 8px 4px;
  border: 1px solid #333;
  border-radius: 3px;
  background: #2a2a2a;
}
.voice-all {
  border-color: #4a8fff;
  background: #252530;
}
.voice-all .voice-label {
  color: #4a8fff;
}
.voice-label {
  font-size: 7px;
  letter-spacing: 1px;
  text-transform: uppercase;
  color: #f0a020;
  text-align: center;
  min-height: 22px;
  word-break: break-all;
  display: flex;
  align-items: center;
  justify-content: center;
}
.voice-note {
  font-size: 7px;
  color: #555;
  letter-spacing: 1px;
}
.knob-row   { display: flex; flex-direction: column; align-items: center; gap: 1px; }
.knob-label { font-size: 7px; letter-spacing: 1px; color: #888; text-transform: uppercase; }
canvas[data-param] { display: block; cursor: ns-resize; }
.knob-value { font-size: 8px; color: #bbb; min-width: 30px; text-align: center; }
.pad {
  margin-top: 6px;
  width: 50px;
  height: 24px;
  background: #3a3a3a;
  border: 1px solid #555;
  border-radius: 3px;
  cursor: pointer;
  font-size: 11px;
  color: #aaa;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: background 0.05s, color 0.05s;
}
.pad:hover  { border-color: #888; color: #ccc; }
.pad.active { background: #f0a020; color: #111; border-color: #f0a020; }
</style>
</head>
<body>

<header>
  <h1>S2800</h1>
  <select id="prog-select"><option>-- connect MIDI --</option></select>
  <div id="midi-bar">WebMIDI: initializing...</div>
  <div id="status" class="info">Waiting for MIDI...</div>
</header>

<div id="sticky-header">
  <div class="section-label">Program</div>
  <div id="prog-panel"></div>
</div>

<div id="scrollable-body">
  <div class="section-label">Per Keygroup</div>
  <div id="panel"><span id="panel-loading">connecting...</span></div>
</div>

<script>
// ── S2800 SysEx constants ────────────────────────────────────────────────────
const AKAI_MFR        = 0x47;
const AKAI_MODEL      = 0x48;
const AKAI_CHANNEL    = 0;
const FUNC_RPLIST     = 0x02;   // request program list
const FUNC_PLIST      = 0x03;   // program list response
const FUNC_S3K_RPDATA = 0x27;   // request program header
const FUNC_S3K_PDATA  = 0x28;   // send/receive program header
const FUNC_S3K_RKDATA = 0x29;   // request keygroup header
const FUNC_S3K_KDATA  = 0x2A;   // send/receive keygroup header
const MIDI_DRUM_CH    = 10;     // WebMIDI.js uses 1-16

// ── Akai character encoding ──────────────────────────────────────────────────
const AKAI_CHARS = '0123456789 ABCDEFGHIJKLMNOPQRSTUVWXYZ#+-./'

const decodeAkaiName = bytes =>
  Array.from(bytes, b => b < AKAI_CHARS.length ? AKAI_CHARS[b] : '?')
       .join('').trimEnd();

// ── Parameter definitions ────────────────────────────────────────────────────
// Program-level parameters read from the 192-byte program header.
const PROG_PARAMS = [
  { name: "PANPOS", label: "PAN",     offset: 24, size: 1, signed: true,  min: -50, max: 50,  center: 0    },
  { name: "PRLOUD", label: "LOUD",    offset: 25, size: 1, signed: false, min: 0,   max: 99,  center: null },
  { name: "STEREO", label: "STEREO",  offset: 23, size: 1, signed: false, min: 0,   max: 99,  center: null },
  { name: "PTUNO",  label: "TUNE",    offset: 65, size: 2, signed: true,  min: -50, max: 50,  center: 0,    scale: 100 },
  { name: "LFORAT", label: "LFO RT",  offset: 33, size: 1, signed: false, min: 0,   max: 99,  center: null },
  { name: "LFODEP", label: "LFO DEP", offset: 34, size: 1, signed: false, min: 0,   max: 99,  center: null },
  { name: "PANRAT", label: "PAN RT",  offset: 29, size: 1, signed: false, min: 0,   max: 99,  center: null },
  { name: "PANDEP", label: "PAN DEP", offset: 30, size: 1, signed: false, min: 0,   max: 99,  center: null },
];

// Per-keygroup parameters read from each 191-byte keygroup header.
// DECAY only has audible effect when SUSTN is low (drag SUSTN to 0 first).
const ALL_PARAMS = [
  { name: "KGTUNO", label: "TUNE",   offset: 5,  size: 2, signed: true,  min: -50, max: 50,  center: 0,    scale: 100 },
  { name: "VLOUD1", label: "LEVEL",  offset: 50, size: 1, signed: true,  min: -50, max: 50,  center: 0    },
  { name: "VPANO1", label: "PAN",    offset: 52, size: 1, signed: true,  min: -50, max: 50,  center: 0    },
  { name: "ATTAK1", label: "ATTACK", offset: 12, size: 1, signed: false, min: 0,   max: 99,  center: null },
  { name: "DECAY1", label: "DECAY",  offset: 13, size: 1, signed: false, min: 0,   max: 99,  center: null },
  { name: "SUSTN1", label: "SUSTN",  offset: 14, size: 1, signed: false, min: 0,   max: 99,  center: null },
  { name: "RELSE1", label: "RELSE",  offset: 15, size: 1, signed: false, min: 0,   max: 99,  center: null },
  { name: "FILFRQ", label: "FILTER", offset: 7,  size: 1, signed: false, min: 0,   max: 99,  center: null },
];

const PARAMS = ALL_PARAMS;  // All 8 params in keygroup columns

// Keygroup metadata offsets (read alongside params, not editable here)
const KG_META = {
  LONOTE: 3,            // 1 byte: lower key range (MIDI note), used as trigger note
  SNAME1: [34, 12],     // 12 bytes: Akai-encoded sample name for zone 1
};

// Program header metadata offsets
const PROG_META = {
  PRNAME: [3, 12],      // 12 bytes: program name
  GROUPS: 42,           // 1 byte: number of keygroups
};

// ── App state ────────────────────────────────────────────────────────────────
let program  = parseInt(new URLSearchParams(location.search).get('program') ?? '0');
let voices   = [];      // built dynamically: [{ label, kg, note }]
let state    = {};      // kg -> { paramName -> value }
let allState = {};      // "ALL" column state (virtual, broadcasts to all keygroups)
let progState = {};     // paramName -> value
let output   = null;
let input    = null;
let loadId   = 0;       // increments on each loadState call; stale loads abort
let numKg    = 0;       // number of keygroups in current program

// ── SysEx codec ──────────────────────────────────────────────────────────────
const nibbleEncode = bytes =>
  bytes.flatMap(b => [b & 0x0F, (b >> 4) & 0x0F]);

const nibbleDecode = nibbles => {
  const out = [];
  for (let i = 0; i + 1 < nibbles.length; i += 2)
    out.push((nibbles[i] & 0x0F) | ((nibbles[i + 1] & 0x0F) << 4));
  return out;
};

const extractField = (raw, { offset, size, signed, scale = 1 }) => {
  let v = size === 1 ? raw[offset] : raw[offset] | (raw[offset + 1] << 8);
  if (signed && size === 1 && v > 127)   v -= 256;
  if (signed && size === 2 && v > 32767) v -= 65536;
  return Math.round(v / scale);
};

const fieldToBytes = (value, { size, scale = 1 }) => {
  const raw = Math.round(value * scale);
  return size === 1 ? [raw & 0xFF] : [raw & 0xFF, (raw >> 8) & 0xFF];
};

// ── Pending SysEx reads ──────────────────────────────────────────────────────
const pendingReads  = new Map();  // `kg_${prog}_${kg}` -> { resolve, reject, timer }
let pendingProgRead = null;
let pendingProgList = null;

function onSysex(e) {
  const d = e.message.data;
  if (d[0] !== 0xF0 || d[1] !== AKAI_MFR || d[4] !== AKAI_MODEL) return;
  const func    = d[3];
  const payload = d.slice(5, -1);

  // Program list response: count(2) + name[12] * count
  if (func === FUNC_PLIST && pendingProgList) {
    clearTimeout(pendingProgList.timer);
    const entry = pendingProgList;
    pendingProgList = null;
    const count = payload[0] | (payload[1] << 8);
    const names = Array.from({ length: count }, (_, i) =>
      decodeAkaiName(payload.slice(2 + i * 12, 14 + i * 12))
    );
    entry.resolve(names);
    return;
  }

  // Program header response: pp PP 00 oo_lo oo_hi nn_lo nn_hi nibbled...
  if (func === FUNC_S3K_PDATA && pendingProgRead) {
    clearTimeout(pendingProgRead.timer);
    const entry = pendingProgRead;
    pendingProgRead = null;
    entry.resolve(nibbleDecode(Array.from(payload.slice(7))));
    return;
  }

  // Keygroup header response: pp PP kk oo_lo oo_hi nn_lo nn_hi nibbled...
  if (func === FUNC_S3K_KDATA) {
    const prog = payload[0] | (payload[1] << 8);
    const kg   = payload[2];
    const entry = pendingReads.get(`kg_${prog}_${kg}`);
    if (!entry) return;
    clearTimeout(entry.timer);
    pendingReads.delete(`kg_${prog}_${kg}`);
    entry.resolve(nibbleDecode(Array.from(payload.slice(7))));
  }
}

// ── Read functions ───────────────────────────────────────────────────────────
function listPrograms() {
  return new Promise((resolve, reject) => {
    const timer = setTimeout(() => { pendingProgList = null; reject(new Error('Timeout')); }, 5000);
    pendingProgList = { resolve, reject, timer };
    output.sendSysex(AKAI_MFR, [AKAI_CHANNEL, FUNC_RPLIST, AKAI_MODEL]);
  });
}

function readProgHeader(prog) {
  return new Promise((resolve, reject) => {
    const timer = setTimeout(() => { pendingProgRead = null; reject(new Error('Timeout')); }, 5000);
    pendingProgRead = { resolve, reject, timer };
    output.sendSysex(AKAI_MFR, [
      AKAI_CHANNEL, FUNC_S3K_RPDATA, AKAI_MODEL,
      prog & 0x7F, (prog >> 7) & 0x7F,
      0x00,
      0x00, 0x00,
      192 & 0x7F, 1,
    ]);
  });
}

function readKg(prog, kg) {
  return new Promise((resolve, reject) => {
    const key = `kg_${prog}_${kg}`;
    const timer = setTimeout(() => { pendingReads.delete(key); reject(new Error('Timeout')); }, 5000);
    pendingReads.set(key, { resolve, reject, timer });
    output.sendSysex(AKAI_MFR, [
      AKAI_CHANNEL, FUNC_S3K_RKDATA, AKAI_MODEL,
      prog & 0x7F, (prog >> 7) & 0x7F,
      kg & 0x7F,
      0x00, 0x00,
      191 & 0x7F, 1,
    ]);
  });
}

// ── Write functions (debounced 30ms, fire-and-forget) ────────────────────────
const writeTimers = new Map();

function scheduleWrite(target, key, param, value) {
  const timerKey = `${target}_${key}_${param.name}`;
  clearTimeout(writeTimers.get(timerKey));
  writeTimers.set(timerKey, setTimeout(() => {
    writeTimers.delete(timerKey);
    const raw = fieldToBytes(value, param);
    if (target === 'prog') {
      output.sendSysex(AKAI_MFR, [
        AKAI_CHANNEL, FUNC_S3K_PDATA, AKAI_MODEL,
        program & 0x7F, (program >> 7) & 0x7F,
        0x00,
        param.offset & 0x7F, (param.offset >> 7) & 0x7F,
        raw.length & 0x7F, (raw.length >> 7) & 0x7F,
        ...nibbleEncode(raw),
      ]);
      setStatus(`PROG ${param.name} \u2192 ${value}`, 'ok');
    } else {
      const kg = parseInt(key);
      output.sendSysex(AKAI_MFR, [
        AKAI_CHANNEL, FUNC_S3K_KDATA, AKAI_MODEL,
        program & 0x7F, (program >> 7) & 0x7F,
        kg & 0x7F,
        param.offset & 0x7F, (param.offset >> 7) & 0x7F,
        raw.length & 0x7F, (raw.length >> 7) & 0x7F,
        ...nibbleEncode(raw),
      ]);
      setStatus(`${param.label} kg${kg} \u2192 ${value}`, 'ok');
    }
  }, 30));
}

// ── Program selector ─────────────────────────────────────────────────────────
async function populateProgramSelector() {
  try {
    const names = await listPrograms();
    const sel = document.getElementById('prog-select');
    sel.innerHTML = '';
    names.forEach((name, i) => {
      const opt = document.createElement('option');
      opt.value = i;
      opt.textContent = `${i}  ${name}`;
      if (i === program) opt.selected = true;
      sel.appendChild(opt);
    });
    if (!names.length) sel.innerHTML = '<option>no programs</option>';
  } catch {
    // leave selector as-is, device may not have responded
  }
}

document.getElementById('prog-select').addEventListener('change', e => {
  program = parseInt(e.target.value);
  history.replaceState(null, '', `?program=${program}`);
  cancelPendingReads();
  loadState();
});

function cancelPendingReads() {
  if (pendingProgRead) { clearTimeout(pendingProgRead.timer); pendingProgRead = null; }
  if (pendingProgList) { clearTimeout(pendingProgList.timer); pendingProgList = null; }
  pendingReads.forEach(e => clearTimeout(e.timer));
  pendingReads.clear();
}

// ── State load ───────────────────────────────────────────────────────────────
// loadId prevents a superseded load from updating the UI after a program switch.
async function loadState() {
  const myId = ++loadId;

  state = {};
  voices = [];
  numKg = 0;
  allState = Object.fromEntries(PARAMS.map(p => [p.name, p.center ?? Math.round((p.min + p.max) / 2)]));
  document.getElementById('panel').innerHTML =
    '<span id="panel-loading">loading...</span>';

  // 1. Read program header: prog params + name + keygroup count
  setStatus('Reading program header...', 'info');
  try {
    const raw = await readProgHeader(program);
    if (loadId !== myId) return;
    progState   = Object.fromEntries(PROG_PARAMS.map(p => [p.name, extractField(raw, p)]));
    numKg       = raw[PROG_META.GROUPS] || 0;
    const name  = decodeAkaiName(raw.slice(PROG_META.PRNAME[0], PROG_META.PRNAME[0] + PROG_META.PRNAME[1]));
    // Update selector to show the real name (in case it wasn't listed yet)
    const opt = document.querySelector(`#prog-select option[value="${program}"]`);
    if (opt && !opt.textContent.includes(name)) opt.textContent = `${program}  ${name}`;
    refreshProgPanel();
  } catch {
    if (loadId !== myId) return;
    progState = Object.fromEntries(PROG_PARAMS.map(p => [p.name, 0]));
    refreshProgPanel();
    setStatus('Program header timeout', 'err');
  }

  if (!numKg) {
    setStatus('No keygroups in this program', 'err');
    buildPanel();
    return;
  }

  // 2. Read each keygroup: extract metadata (name, note) AND params in one pass
  let loaded = 0;
  for (let kgIdx = 0; kgIdx < numKg; kgIdx++) {
    if (loadId !== myId) return;
    setStatus(`Reading keygroup ${kgIdx + 1}/${numKg}...`, 'info');
    try {
      const raw    = await readKg(program, kgIdx);
      if (loadId !== myId) return;
      const sname  = decodeAkaiName(raw.slice(KG_META.SNAME1[0], KG_META.SNAME1[0] + KG_META.SNAME1[1]));
      const loNote = raw[KG_META.LONOTE];
      voices.push({ label: sname || `KG ${kgIdx}`, kg: kgIdx, note: loNote });
      state[kgIdx] = Object.fromEntries(PARAMS.map(p => [p.name, extractField(raw, p)]));
      loaded++;
    } catch {
      if (loadId !== myId) return;
      voices.push({ label: `KG ${kgIdx}`, kg: kgIdx, note: 60 });
      state[kgIdx] = Object.fromEntries(PARAMS.map(p => [p.name, 0]));
    }
  }

  // 3. Build panel from discovered voices, then populate knob values
  buildPanel();
  if (voices.length > 0) refreshVoice({ label: 'ALL', kg: 'all', note: null });
  for (const voice of voices) refreshVoice(voice);
  setStatus(
    `${loaded}/${numKg} keygroups loaded. Drag to edit | Ctrl+click: reset knob | Alt+click: reset column | Shift+drag or ALL: broadcast`,
    loaded > 0 ? 'ok' : 'err'
  );
}

// ── UI: program panel ─────────────────────────────────────────────────────────
function buildProgPanel() {
  const panel = document.getElementById('prog-panel');
  panel.innerHTML = '';
  for (const param of PROG_PARAMS) {
    const group = document.createElement('div');
    group.className = 'prog-knob-group';

    const lbl = document.createElement('div');
    lbl.className = 'prog-knob-label';
    lbl.textContent = param.label;

    const cvs = document.createElement('canvas');
    cvs.width = cvs.height = 44;
    cvs.dataset.target = 'prog';
    cvs.dataset.param  = param.name;
    cvs.title = `${param.name}: ${param.min} to ${param.max}`;

    const vEl = document.createElement('div');
    vEl.className = 'prog-knob-value';
    vEl.id = `pv_${param.name}`;
    vEl.textContent = '0';

    const nameLbl = document.createElement('div');
    nameLbl.className = 'prog-knob-name';
    nameLbl.textContent = param.name;

    group.append(lbl, cvs, vEl, nameLbl);
    panel.appendChild(group);
  }
}

function refreshProgPanel() {
  for (const param of PROG_PARAMS) {
    const val = progState[param.name] ?? 0;
    const vEl = document.getElementById(`pv_${param.name}`);
    const cvs = document.querySelector(`canvas[data-target="prog"][data-param="${param.name}"]`);
    if (vEl) vEl.textContent = val;
    if (cvs) drawKnob(cvs, val, param);
  }
}

// ── UI: keygroup panel (built from dynamic voices) ────────────────────────────
function buildPanel() {
  const panel = document.getElementById('panel');
  panel.innerHTML = '';

  // Add "ALL" column first (broadcasts to all keygroups)
  if (voices.length > 0) {
    panel.appendChild(buildColumn({ label: 'ALL', kg: 'all', note: null }));
  }

  // Add individual voice columns
  for (const voice of voices) panel.appendChild(buildColumn(voice));
}

function buildColumn(voice) {
  const col = document.createElement('div');
  col.className = voice.kg === 'all' ? 'voice voice-all' : 'voice';

  const lbl = document.createElement('div');
  lbl.className = 'voice-label';
  lbl.textContent = voice.label;
  col.appendChild(lbl);

  // Only show note label for individual keygroups, not ALL
  if (voice.kg !== 'all') {
    const noteLbl = document.createElement('div');
    noteLbl.className = 'voice-note';
    noteLbl.textContent = `n${voice.note}`;
    col.appendChild(noteLbl);
  } else {
    // Add spacer for ALL column to align with other columns
    const spacer = document.createElement('div');
    spacer.className = 'voice-note';
    spacer.textContent = 'broadcast';
    spacer.style.color = '#777';
    col.appendChild(spacer);
  }

  for (const param of PARAMS) {
    const row  = document.createElement('div');
    row.className = 'knob-row';

    const klbl = document.createElement('div');
    klbl.className = 'knob-label';
    klbl.textContent = param.label;

    const cvs = document.createElement('canvas');
    cvs.width = cvs.height = 48;
    cvs.dataset.target = 'kg';
    cvs.dataset.kg     = voice.kg;
    cvs.dataset.param  = param.name;
    cvs.title = voice.kg === 'all'
      ? `${param.label} - broadcasts to all keygroups`
      : `${param.label} (${param.min} to ${param.max})`;

    const vEl = document.createElement('div');
    vEl.className = 'knob-value';
    vEl.id = `kv_${voice.kg}_${param.name}`;
    vEl.textContent = '0';

    row.append(klbl, cvs, vEl);
    col.appendChild(row);
  }

  // Only add pad button for individual keygroups, not ALL
  if (voice.kg !== 'all') {
    const pad = document.createElement('button');
    pad.className = 'pad';
    pad.dataset.note = voice.note;
    pad.textContent = '\u25b6';
    pad.title = `${voice.label} \u2014 note ${voice.note}`;
    col.appendChild(pad);
  }

  return col;
}

function refreshVoice(voice) {
  for (const param of PARAMS) {
    const val = voice.kg === 'all'
      ? (allState[param.name] ?? 0)
      : (state[voice.kg] ?? {})[param.name] ?? 0;
    const vEl = document.getElementById(`kv_${voice.kg}_${param.name}`);
    const cvs = document.querySelector(
      `canvas[data-kg="${voice.kg}"][data-param="${param.name}"]`
    );
    if (vEl) vEl.textContent = val;
    if (cvs) drawKnob(cvs, val, param);
  }
}

// ── Knob rendering ────────────────────────────────────────────────────────────
function drawKnob(cvs, value, param) {
  const ctx = cvs.getContext('2d');
  const W = cvs.width, H = cvs.height, cx = W / 2, cy = H / 2;
  const r = Math.min(W, H) / 2 - 4;
  ctx.clearRect(0, 0, W, H);

  ctx.beginPath();
  ctx.arc(cx, cy, r, 0, 2 * Math.PI);
  ctx.fillStyle = '#1a1a1a';
  ctx.fill();
  ctx.strokeStyle = '#444';
  ctx.lineWidth = 1.5;
  ctx.stroke();

  const A0    = 0.75 * Math.PI;
  const SWEEP = 1.5 * Math.PI;
  const norm  = (value - param.min) / (param.max - param.min);
  const angle = A0 + norm * SWEEP;

  ctx.beginPath();
  ctx.arc(cx, cy, r - 3, A0, angle);
  ctx.strokeStyle = cvs.dataset.target === 'prog' ? '#4a8fff' : '#f0a020';
  ctx.lineWidth = 3;
  ctx.stroke();

  ctx.beginPath();
  ctx.moveTo(cx, cy);
  ctx.lineTo(cx + (r - 7) * Math.cos(angle), cy + (r - 7) * Math.sin(angle));
  ctx.strokeStyle = '#fff';
  ctx.lineWidth = 1.5;
  ctx.stroke();
}

// ── Unified drag handler ──────────────────────────────────────────────────────
let drag = null;

document.body.addEventListener('mousedown', e => {
  const isPad = e.target.closest('.pad');
  if (isPad) { isPad.classList.add('active'); return; }

  const cvs = e.target.closest('canvas[data-param]');
  if (!cvs) return;

  const target  = cvs.dataset.target;
  const paramList = target === 'prog' ? PROG_PARAMS : PARAMS;
  const param   = paramList.find(p => p.name === cvs.dataset.param);
  if (!param) return;

  // Alt+click (or Option+click on macOS) resets entire column to defaults
  if (e.altKey) {
    const kgRaw = cvs.dataset.kg;
    const kg    = kgRaw === 'all' ? 'all' : parseInt(kgRaw);

    if (target === 'kg') {
      // Reset all knobs in this column
      for (const p of PARAMS) {
        const def = p.center !== null ? p.center : Math.round((p.min + p.max) / 2);

        if (kg === 'all') {
          allState[p.name] = def;
          const vEl = document.getElementById(`kv_all_${p.name}`);
          const canvas = document.querySelector(`canvas[data-kg="all"][data-param="${p.name}"]`);
          if (vEl) vEl.textContent = def;
          if (canvas) drawKnob(canvas, def, p);
          if (output) {
            for (let i = 0; i < numKg; i++) {
              scheduleWrite('kg', i, p, def);
            }
          }
        } else {
          if (!state[kg]) state[kg] = {};
          state[kg][p.name] = def;
          const vEl = document.getElementById(`kv_${kg}_${p.name}`);
          const canvas = document.querySelector(`canvas[data-kg="${kg}"][data-param="${p.name}"]`);
          if (vEl) vEl.textContent = def;
          if (canvas) drawKnob(canvas, def, p);
          if (output) scheduleWrite('kg', kg, p, def);
        }
      }
      setStatus(
        kg === 'all'
          ? `All knobs reset to defaults (broadcast to all ${numKg} keygroups)`
          : `Column ${kg} reset to defaults`,
        'ok'
      );
    }
    e.preventDefault();
    return;
  }

  // Ctrl+click (or Cmd+click on macOS) resets single knob to default
  if (e.ctrlKey || e.metaKey) {
    const kgRaw = cvs.dataset.kg;
    const kg    = kgRaw === 'all' ? 'all' : parseInt(kgRaw);
    const def   = param.center !== null
      ? param.center
      : Math.round((param.min + param.max) / 2);

    if (target === 'prog') {
      progState[param.name] = def;
      const vEl = document.getElementById(`pv_${param.name}`);
      if (vEl) vEl.textContent = def;
      drawKnob(cvs, def, param);
      if (output) scheduleWrite('prog', 'prog', param, def);
    } else if (kg === 'all') {
      allState[param.name] = def;
      const vEl = document.getElementById(`kv_all_${param.name}`);
      if (vEl) vEl.textContent = def;
      drawKnob(cvs, def, param);
      if (output) {
        for (let i = 0; i < numKg; i++) {
          scheduleWrite('kg', i, param, def);
        }
      }
    } else {
      if (!state[kg]) state[kg] = {};
      state[kg][param.name] = def;
      const vEl = document.getElementById(`kv_${kg}_${param.name}`);
      if (vEl) vEl.textContent = def;
      drawKnob(cvs, def, param);
      if (output) scheduleWrite('kg', kg, param, def);
    }
    e.preventDefault();
    return;
  }

  const kgRaw    = cvs.dataset.kg;
  const kg       = kgRaw === 'all' ? 'all' : parseInt(kgRaw);
  const startVal = target === 'prog'
    ? progState[param.name] ?? 0
    : kg === 'all'
      ? allState[param.name] ?? 0
      : (state[kg] ?? {})[param.name] ?? 0;

  drag = { cvs, target, kg, param, startY: e.clientY, startVal, shiftKey: e.shiftKey };
  e.preventDefault();
});

window.addEventListener('mousemove', e => {
  if (!drag) return;
  const { cvs, target, kg, param, startY, startVal, shiftKey } = drag;
  const delta  = (startY - e.clientY) * (param.max - param.min) / 150;
  const newVal = Math.max(param.min, Math.min(param.max, Math.round(startVal + delta)));

  if (target === 'prog') {
    progState[param.name] = newVal;
    const vEl = document.getElementById(`pv_${param.name}`);
    if (vEl) vEl.textContent = newVal;
    drawKnob(cvs, newVal, param);
    if (output) scheduleWrite('prog', 'prog', param, newVal);
  } else if (kg === 'all') {
    // ALL column: update allState and broadcast to all keygroups
    allState[param.name] = newVal;
    const vEl = document.getElementById(`kv_all_${param.name}`);
    if (vEl) vEl.textContent = newVal;
    drawKnob(cvs, newVal, param);
    if (output) {
      for (let i = 0; i < numKg; i++) {
        scheduleWrite('kg', i, param, newVal);
      }
      setStatus(`${param.label} \u2192 ${newVal} (broadcast to all ${numKg} keygroups)`, 'ok');
    }
  } else if (shiftKey) {
    // Shift+drag on individual keygroup: broadcast to all
    if (!state[kg]) state[kg] = {};
    state[kg][param.name] = newVal;
    const vEl = document.getElementById(`kv_${kg}_${param.name}`);
    if (vEl) vEl.textContent = newVal;
    drawKnob(cvs, newVal, param);
    if (output) {
      for (let i = 0; i < numKg; i++) {
        scheduleWrite('kg', i, param, newVal);
      }
      setStatus(`${param.label} \u2192 ${newVal} (Shift+drag broadcast to all ${numKg})`, 'ok');
    }
  } else {
    // Normal single-keygroup drag
    if (!state[kg]) state[kg] = {};
    state[kg][param.name] = newVal;
    const vEl = document.getElementById(`kv_${kg}_${param.name}`);
    if (vEl) vEl.textContent = newVal;
    drawKnob(cvs, newVal, param);
    if (output) scheduleWrite('kg', kg, param, newVal);
  }
});

window.addEventListener('mouseup', () => {
  drag = null;
  document.querySelectorAll('.pad.active').forEach(p => p.classList.remove('active'));
});

document.body.addEventListener('dblclick', e => {
  const cvs = e.target.closest('canvas[data-param]');
  if (!cvs) return;
  const target    = cvs.dataset.target;
  const paramList = target === 'prog' ? PROG_PARAMS : PARAMS;
  const param     = paramList.find(p => p.name === cvs.dataset.param);
  if (!param) return;
  const kgRaw = cvs.dataset.kg;
  const kg    = kgRaw === 'all' ? 'all' : parseInt(kgRaw);
  const def   = param.center !== null
    ? param.center
    : Math.round((param.min + param.max) / 2);

  if (target === 'prog') {
    progState[param.name] = def;
    const vEl = document.getElementById(`pv_${param.name}`);
    if (vEl) vEl.textContent = def;
    drawKnob(cvs, def, param);
    if (output) scheduleWrite('prog', 'prog', param, def);
  } else if (kg === 'all') {
    allState[param.name] = def;
    const vEl = document.getElementById(`kv_all_${param.name}`);
    if (vEl) vEl.textContent = def;
    drawKnob(cvs, def, param);
    if (output) {
      for (let i = 0; i < numKg; i++) {
        scheduleWrite('kg', i, param, def);
      }
    }
  } else {
    if (!state[kg]) state[kg] = {};
    state[kg][param.name] = def;
    const vEl = document.getElementById(`kv_${kg}_${param.name}`);
    if (vEl) vEl.textContent = def;
    drawKnob(cvs, def, param);
    if (output) scheduleWrite('kg', kg, param, def);
  }
});

// ── Hits ──────────────────────────────────────────────────────────────────────
document.body.addEventListener('click', e => {
  const pad = e.target.closest('.pad');
  if (!pad || !output) return;
  output.channels[MIDI_DRUM_CH].playNote(
    parseInt(pad.dataset.note),
    { duration: 200, rawAttack: 100 }
  );
});

// ── Status ────────────────────────────────────────────────────────────────────
function setStatus(msg, cls = '') {
  const el = document.getElementById('status');
  el.textContent = msg;
  el.className = cls;
}

// ── WebMIDI.js bootstrap ──────────────────────────────────────────────────────
const PORT_PATTERNS = ['Volt', 'S2800', 'Akai', 'AKAI'];

WebMidi.enable({ sysex: true }).then(() => {
  for (const pat of PORT_PATTERNS) {
    const o = WebMidi.outputs.find(p => p.name.includes(pat));
    const i = WebMidi.inputs.find(p => p.name.includes(pat));
    if (o && i) { output = o; input = i; break; }
  }
  if (!output && WebMidi.outputs.length) {
    output = WebMidi.outputs[0];
    input  = WebMidi.inputs[0] ?? null;
  }

  if (!output) {
    document.getElementById('midi-bar').textContent =
      'No MIDI ports found. Connect S2800 and reload.';
    setStatus('No MIDI device', 'err');
    buildProgPanel();
    return;
  }

  document.getElementById('midi-bar').textContent = `MIDI: ${output.name}`;
  if (input) input.addListener('sysex', onSysex);

  buildProgPanel();
  populateProgramSelector().then(() => loadState());

}).catch(err => {
  document.getElementById('midi-bar').textContent = `WebMIDI failed: ${err.message}`;
  setStatus('MIDI unavailable. Check browser permissions.', 'err');
  buildProgPanel();
});
</script>
</body>
</html>
