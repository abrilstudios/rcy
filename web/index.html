<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>RCY Web</title>
  <script src="https://unpkg.com/wavesurfer.js@7"></script>
  <script src="https://unpkg.com/wavesurfer.js@7/dist/plugins/regions.min.js"></script>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, monospace;
      background: #1a1a2e;
      color: #eee;
      min-height: 100vh;
      padding: 20px;
    }
    .container { max-width: 1200px; margin: 0 auto; }
    h1 { font-size: 1.5rem; margin-bottom: 20px; color: #00d4ff; }

    #drop-zone {
      border: 2px dashed #444;
      border-radius: 8px;
      padding: 40px;
      text-align: center;
      margin-bottom: 20px;
      transition: all 0.2s;
    }
    #drop-zone.dragover { border-color: #00d4ff; background: rgba(0,212,255,0.1); }
    #drop-zone p { color: #888; }

    #waveform {
      background: #0f0f1a;
      border-radius: 8px;
      margin-bottom: 20px;
      min-height: 128px;
    }

    .controls {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      margin-bottom: 20px;
    }
    button {
      background: #333;
      color: #fff;
      border: 1px solid #555;
      padding: 10px 20px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
      transition: all 0.2s;
    }
    button:hover { background: #444; border-color: #00d4ff; }
    button:disabled { opacity: 0.5; cursor: not-allowed; }
    button.active { background: #00d4ff; color: #000; }

    .input-group {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    input[type="number"] {
      background: #222;
      border: 1px solid #444;
      color: #fff;
      padding: 10px;
      width: 80px;
      border-radius: 4px;
    }
    label { color: #888; font-size: 14px; }

    .info {
      background: #0f0f1a;
      padding: 15px;
      border-radius: 8px;
      font-size: 13px;
      color: #888;
      margin-bottom: 20px;
    }
    .info span { color: #00d4ff; }
    .info .latency { color: #4ecdc4; }

    .segments {
      display: flex;
      gap: 5px;
      flex-wrap: wrap;
    }
    .segment-btn {
      width: 44px;
      height: 44px;
      font-size: 14px;
      font-weight: bold;
      padding: 0;
      position: relative;
    }
    .segment-btn:hover { background: #00d4ff; color: #000; }
    .segment-btn.playing {
      background: #ff6b6b;
      border-color: #ff6b6b;
    }
    .segment-btn .key {
      position: absolute;
      bottom: 2px;
      right: 4px;
      font-size: 9px;
      color: #666;
    }
    .segment-btn:hover .key { color: #000; }
  </style>
</head>
<body>
  <div class="container">
    <h1>RCY Web</h1>

    <div id="drop-zone">
      <p>Drop audio file here or <input type="file" id="file-input" accept="audio/*" style="display:none">
      <button onclick="document.getElementById('file-input').click()">Browse</button></p>
    </div>

    <div id="waveform"></div>

    <div class="controls">
      <button id="play-btn" disabled>▶ Play All</button>
      <button id="stop-btn" disabled>■ Stop</button>
      <div class="input-group">
        <label>Bars:</label>
        <input type="number" id="bars-input" value="4" min="1" max="64">
      </div>
      <div class="input-group">
        <label>Slices:</label>
        <input type="number" id="slices-input" value="16" min="1" max="64">
      </div>
      <button id="slice-btn" disabled>Slice</button>
      <button id="clear-btn" disabled>Clear</button>
    </div>

    <div class="info">
      <div>File: <span id="filename">-</span></div>
      <div>Duration: <span id="duration">-</span>s | BPM: <span id="bpm">-</span> | Latency: <span id="latency" class="latency">-</span></div>
    </div>

    <div class="segments" id="segments"></div>
  </div>

  <script type="module">
    /**
     * RCY Web Audio Engine
     *
     * Architecture:
     * - AudioContext with "interactive" latency hint for lowest latency
     * - Pre-decoded AudioBuffer for instant playback
     * - AudioBufferSourceNode per segment trigger (one-shot, no reuse)
     * - Wavesurfer.js for visualization only (not playback)
     */

    class AudioEngine {
      constructor() {
        this.audioCtx = null;
        this.audioBuffer = null;
        this.activeSource = null;
        this.isPlaying = false;
      }

      async init() {
        // Create context with lowest latency hint
        this.audioCtx = new AudioContext({
          latencyHint: 'interactive',
          sampleRate: 44100
        });

        // Resume context (required after user gesture)
        if (this.audioCtx.state === 'suspended') {
          await this.audioCtx.resume();
        }

        return {
          sampleRate: this.audioCtx.sampleRate,
          baseLatency: this.audioCtx.baseLatency,
          outputLatency: this.audioCtx.outputLatency || 0
        };
      }

      async loadFile(file) {
        if (!this.audioCtx) await this.init();

        // Read file as ArrayBuffer
        const arrayBuffer = await file.arrayBuffer();

        // Decode audio data (this is the expensive operation - do it once)
        this.audioBuffer = await this.audioCtx.decodeAudioData(arrayBuffer);

        return {
          duration: this.audioBuffer.duration,
          sampleRate: this.audioBuffer.sampleRate,
          channels: this.audioBuffer.numberOfChannels
        };
      }

      /**
       * Play a segment with minimal latency
       * Uses AudioBufferSourceNode.start(when, offset, duration) for precise timing
       */
      playSegment(startTime, endTime) {
        if (!this.audioBuffer || !this.audioCtx) return null;

        // Resume context if suspended
        if (this.audioCtx.state === 'suspended') {
          this.audioCtx.resume();
        }

        // Create new source node (they are one-shot, cannot be restarted)
        const source = this.audioCtx.createBufferSource();
        source.buffer = this.audioBuffer;
        source.connect(this.audioCtx.destination);

        // Start immediately (0), at offset, for duration
        const duration = endTime - startTime;
        source.start(0, startTime, duration);

        // Track for stopping
        this.activeSource = source;
        this.isPlaying = true;

        // Return promise that resolves when segment ends
        return new Promise(resolve => {
          source.onended = () => {
            if (this.activeSource === source) {
              this.isPlaying = false;
              this.activeSource = null;
            }
            resolve();
          };
        });
      }

      /**
       * Play full buffer
       */
      playAll() {
        if (!this.audioBuffer) return null;
        return this.playSegment(0, this.audioBuffer.duration);
      }

      /**
       * Stop current playback
       */
      stop() {
        if (this.activeSource) {
          try {
            this.activeSource.stop();
          } catch (e) {
            // Already stopped
          }
          this.activeSource = null;
        }
        this.isPlaying = false;
      }

      get duration() {
        return this.audioBuffer?.duration || 0;
      }

      get sampleRate() {
        return this.audioBuffer?.sampleRate || 44100;
      }

      getLatencyInfo() {
        if (!this.audioCtx) return null;
        return {
          baseLatency: this.audioCtx.baseLatency,
          outputLatency: this.audioCtx.outputLatency || 0,
          totalLatency: (this.audioCtx.baseLatency || 0) + (this.audioCtx.outputLatency || 0)
        };
      }
    }

    /**
     * Segment Manager
     */
    class SegmentManager {
      constructor() {
        this.segments = [];
      }

      sliceByMeasures(duration, numSlices) {
        this.segments = [];
        const sliceDuration = duration / numSlices;

        for (let i = 0; i < numSlices; i++) {
          this.segments.push({
            index: i,
            start: i * sliceDuration,
            end: (i + 1) * sliceDuration
          });
        }

        return this.segments;
      }

      clear() {
        this.segments = [];
      }

      getSegment(index) {
        return this.segments[index];
      }

      get count() {
        return this.segments.length;
      }
    }

    /**
     * UI Controller
     */
    class RCYApp {
      constructor() {
        this.engine = new AudioEngine();
        this.segmentManager = new SegmentManager();
        this.wavesurfer = null;
        this.regions = null;
        this.playingSegmentIndex = null;

        this.initUI();
        this.initKeyboard();
      }

      initUI() {
        // File input
        document.getElementById('file-input').onchange = (e) => {
          this.loadFile(e.target.files[0]);
        };

        // Drop zone
        const dropZone = document.getElementById('drop-zone');
        dropZone.ondragover = (e) => {
          e.preventDefault();
          dropZone.classList.add('dragover');
        };
        dropZone.ondragleave = () => dropZone.classList.remove('dragover');
        dropZone.ondrop = (e) => {
          e.preventDefault();
          dropZone.classList.remove('dragover');
          const file = e.dataTransfer.files[0];
          if (file?.type.startsWith('audio/')) {
            this.loadFile(file);
          }
        };

        // Controls
        document.getElementById('play-btn').onclick = () => this.playAll();
        document.getElementById('stop-btn').onclick = () => this.stop();
        document.getElementById('slice-btn').onclick = () => this.slice();
        document.getElementById('clear-btn').onclick = () => this.clearSlices();
        document.getElementById('bars-input').onchange = () => this.updateBPM();
      }

      initKeyboard() {
        // Segment keys: 1-9, 0 for 1-10, q-p for 11-20
        const keyMap = {
          '1': 0, '2': 1, '3': 2, '4': 3, '5': 4,
          '6': 5, '7': 6, '8': 7, '9': 8, '0': 9,
          'q': 10, 'w': 11, 'e': 12, 'r': 13, 't': 14,
          'y': 15, 'u': 16, 'i': 17, 'o': 18, 'p': 19
        };

        document.onkeydown = (e) => {
          if (e.target.tagName === 'INPUT') return;

          const key = e.key.toLowerCase();

          if (key in keyMap) {
            e.preventDefault();
            this.playSegmentByIndex(keyMap[key]);
          } else if (key === ' ') {
            e.preventDefault();
            if (this.engine.isPlaying) {
              this.stop();
            } else {
              this.playAll();
            }
          } else if (key === 'escape') {
            this.stop();
          }
        };
      }

      async loadFile(file) {
        if (!file) return;

        // Initialize audio engine (requires user gesture)
        const initInfo = await this.engine.init();

        // Load and decode audio
        const info = await this.engine.loadFile(file);

        // Update UI
        document.getElementById('filename').textContent = file.name;
        document.getElementById('duration').textContent = info.duration.toFixed(2);

        // Show latency
        const latency = this.engine.getLatencyInfo();
        const totalMs = (latency.totalLatency * 1000).toFixed(1);
        document.getElementById('latency').textContent = `${totalMs}ms`;

        this.updateBPM();
        this.enableControls();

        // Initialize waveform visualization
        this.initWaveform(file);

        // Clear any existing segments
        this.segmentManager.clear();
        this.renderSegmentButtons();
      }

      initWaveform(file) {
        if (this.wavesurfer) {
          this.wavesurfer.destroy();
        }

        this.wavesurfer = WaveSurfer.create({
          container: '#waveform',
          waveColor: '#4a9eff',
          progressColor: '#00d4ff',
          cursorColor: '#ff6b6b',
          height: 128,
          barWidth: 2,
          barGap: 1,
          barRadius: 2,
          interact: false, // Disable interaction - visualization only
        });

        this.regions = this.wavesurfer.registerPlugin(WaveSurfer.Regions.create());

        // Load for visualization only
        const url = URL.createObjectURL(file);
        this.wavesurfer.load(url);
      }

      updateBPM() {
        const duration = this.engine.duration;
        if (!duration) return;

        const bars = parseInt(document.getElementById('bars-input').value) || 4;
        const bpm = (bars * 4 * 60) / duration;
        document.getElementById('bpm').textContent = bpm.toFixed(1);
      }

      enableControls() {
        document.getElementById('play-btn').disabled = false;
        document.getElementById('stop-btn').disabled = false;
        document.getElementById('slice-btn').disabled = false;
        document.getElementById('clear-btn').disabled = false;
      }

      slice() {
        const numSlices = parseInt(document.getElementById('slices-input').value) || 16;
        const segments = this.segmentManager.sliceByMeasures(this.engine.duration, numSlices);

        // Update waveform regions
        if (this.regions) {
          this.regions.clearRegions();
          const colors = ['#ff6b6b40', '#4ecdc440', '#45b7d140', '#96ceb440', '#ffeaa740', '#dda0dd40'];

          segments.forEach((seg, i) => {
            this.regions.addRegion({
              start: seg.start,
              end: seg.end,
              color: colors[i % colors.length],
              drag: false,
              resize: false,
            });
          });
        }

        this.renderSegmentButtons();
      }

      clearSlices() {
        this.segmentManager.clear();
        if (this.regions) {
          this.regions.clearRegions();
        }
        this.renderSegmentButtons();
      }

      renderSegmentButtons() {
        const container = document.getElementById('segments');
        container.innerHTML = '';

        const keyLabels = ['1','2','3','4','5','6','7','8','9','0',
                          'Q','W','E','R','T','Y','U','I','O','P'];

        this.segmentManager.segments.forEach((seg, i) => {
          const btn = document.createElement('button');
          btn.className = 'segment-btn';
          btn.dataset.index = i;
          btn.innerHTML = `${i + 1}<span class="key">${keyLabels[i] || ''}</span>`;
          btn.onclick = () => this.playSegmentByIndex(i);
          container.appendChild(btn);
        });
      }

      async playSegmentByIndex(index) {
        const seg = this.segmentManager.getSegment(index);
        if (!seg) return;

        // Stop any current playback
        this.stop();

        // Update UI
        this.setPlayingSegment(index);

        // Play segment
        await this.engine.playSegment(seg.start, seg.end);

        // Clear UI
        this.setPlayingSegment(null);
      }

      setPlayingSegment(index) {
        // Clear previous
        document.querySelectorAll('.segment-btn.playing').forEach(btn => {
          btn.classList.remove('playing');
        });

        // Set current
        if (index !== null) {
          const btn = document.querySelector(`.segment-btn[data-index="${index}"]`);
          if (btn) btn.classList.add('playing');
        }

        this.playingSegmentIndex = index;
      }

      async playAll() {
        this.stop();
        document.getElementById('play-btn').textContent = '⏸ Pause';
        await this.engine.playAll();
        document.getElementById('play-btn').textContent = '▶ Play All';
      }

      stop() {
        this.engine.stop();
        this.setPlayingSegment(null);
        document.getElementById('play-btn').textContent = '▶ Play All';
      }
    }

    // Initialize app
    const app = new RCYApp();
  </script>
</body>
</html>
